é˜¶æ®µä¸€ï¼šç¯å¢ƒå‡†å¤‡ä¸æµ‹è¯•æ¡†æ¶æ­å»ºÂ 
1. åˆ›å»ºæµ‹è¯•ç›®å½•ç»“æ„
vehicle-detection-system/
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ conftest.py                    # æµ‹è¯•é…ç½®å’Œfixture
â”‚   â”œâ”€â”€ test_config.py                 # é…ç½®æ–‡ä»¶æµ‹è¯•
â”‚   â”œâ”€â”€ test_models.py                 # æ•°æ®æ¨¡å‹æµ‹è¯•
â”‚   â”œâ”€â”€ test_services.py               # æœåŠ¡å±‚æµ‹è¯•
â”‚   â”œâ”€â”€ test_routes.py                 # APIæ¥å£æµ‹è¯•
â”‚   â”œâ”€â”€ test_websocket.py              # WebSocketæµ‹è¯•
â”‚   â”œâ”€â”€ test_coverage.py               # è¦†ç›–ç‡æµ‹è¯•
â”‚   â””â”€â”€ test_security.py               # å®‰å…¨æµ‹è¯•
â”œâ”€â”€ run_experiment.py                  # å®éªŒæ‰§è¡Œä¸»è„šæœ¬
â””â”€â”€ requirements-test.txt              # æµ‹è¯•ä¸“ç”¨ä¾èµ–
2. å®‰è£…æµ‹è¯•ä¾èµ–
# requirements-test.txt
pytest>=7.0.0
pytest-cov>=4.0.0
pytest-asyncio>=0.21.0
pytest-flask>=1.2.0
coverage>=7.0.0
requests-mock>=1.10.0
Flask-Testing>=0.8.0
python-socketio>=5.9.0

é˜¶æ®µäºŒï¼šç¼–å†™æµ‹è¯•ç”¨ä¾‹
1.Â é…ç½®æ–‡ä»¶æµ‹è¯•Â (tests/test_config.py)
import os
import pytest
from app.config.config import Config
from app.config.scheduler_config import scheduler_config

class TestConfig:
    """é…ç½®æ–‡ä»¶æµ‹è¯•"""
    
    def test_database_config(self):
        """æµ‹è¯•æ•°æ®åº“é…ç½®"""
        config = Config()
        
        # éªŒè¯æ•°æ®åº“URIæ ¼å¼
        assert "mysql+pymysql://" in config.SQLALCHEMY_DATABASE_URI
        assert config.SQLALCHEMY_TRACK_MODIFICATIONS is False
        
        # æµ‹è¯•ç¯å¢ƒå˜é‡è¦†ç›–
        os.environ['SQLALCHEMY_ECHO'] = 'true'
        config2 = Config()
        assert config2.SQLALCHEMY_ECHO is True
        
    def test_path_config(self):
        """æµ‹è¯•è·¯å¾„é…ç½®"""
        config = Config()
        
        # éªŒè¯è·¯å¾„å­˜åœ¨æ€§
        assert os.path.exists(config.BASE_DIR)
        assert "MODEL_DIR" in config.MODEL_DIR
        
    def test_scheduler_config(self):
        """æµ‹è¯•å®šæ—¶ä»»åŠ¡é…ç½®"""
        assert 'executors' in scheduler_config
        assert 'job_defaults' in scheduler_config
        assert scheduler_config['job_defaults']['max_instances'] == 3
2.Â æ•°æ®æ¨¡å‹æµ‹è¯•Â (tests/test_models.py)
import pytest
from datetime import datetime
from app import db, create_app
from app.models.camera import Camera
from app.models.detection import Detection
from app.models.violation import Violation
from app.models.user import User

class TestModels:
    """æ•°æ®æ¨¡å‹æµ‹è¯•"""
    
    @pytest.fixture
    def app(self):
        """åˆ›å»ºæµ‹è¯•åº”ç”¨"""
        app = create_app()
        app.config['TESTING'] = True
        app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///:memory:'
        
        with app.app_context():
            db.create_all()
            yield app
            db.session.remove()
            db.drop_all()
    
    def test_camera_model(self, app):
        """æµ‹è¯•æ‘„åƒå¤´æ¨¡å‹"""
        with app.app_context():
            camera = Camera(
                name="æµ‹è¯•æ‘„åƒå¤´",
                ip_address="192.168.1.100",
                port=554,
                url="rtsp://192.168.1.100:554/stream",
                resolution="1920x1080",
                frame_rate=30,
                encoding_format="H.264",
                status="online"
            )
            
            db.session.add(camera)
            db.session.commit()
            
            # éªŒè¯å­—æ®µ
            assert camera.id is not None
            assert camera.name == "æµ‹è¯•æ‘„åƒå¤´"
            assert camera.is_active is True  # é»˜è®¤å€¼
            assert str(camera) == "<Camera æµ‹è¯•æ‘„åƒå¤´ (192.168.1.100:554)>"
    
    def test_detection_model_creation(self, app):
        """æµ‹è¯•æ£€æµ‹è®°å½•åˆ›å»º"""
        with app.app_context():
            detection = Detection(
                camera_id=1,
                timestamp=datetime.now(),
                vehicle_type="car",
                location="Gate 1",
                is_violation=False
            )
            
            db.session.add(detection)
            db.session.commit()
            
            assert detection.id is not None
            assert detection.vehicle_type == "car"
            assert detection.is_violation is False
    
    def test_violation_model_to_dict(self, app):
        """æµ‹è¯•è¿è§„æ¨¡å‹æ•°æ®è½¬æ¢"""
        with app.app_context():
            violation = Violation(
                camera_id=1,
                camera_name="æµ‹è¯•æ‘„åƒå¤´",
                timestamp=datetime.now(),
                vehicle_type="truck",
                location="{'x': 100, 'y': 200}",
                violation_type="parking",
                area_id=1
            )
            
            data = violation.to_dict()
            assert 'camera_id' in data
            assert 'camera_name' in data
            assert 'timestamp' in data
            assert 'vehicle_type' in data
    
    def test_user_model_authentication(self, app):
        """æµ‹è¯•ç”¨æˆ·æ¨¡å‹"""
        with app.app_context():
            from werkzeug.security import generate_password_hash
            
            user = User(
                username="testuser",
                password=generate_password_hash("password123"),
                role="admin"
            )
            
            db.session.add(user)
            db.session.commit()
            
            assert user.username == "testuser"
            assert user.role == "admin"

3.Â æœåŠ¡å±‚æµ‹è¯•Â (tests/test_services.py)
import pytest
from unittest.mock import Mock, patch, AsyncMock
from datetime import datetime, timedelta
from app.services.camera_service import CameraService
from app.services.detection_service import DetectionService
from app.services.violation_service import ViolationService
from app.services.auth_service import authenticate_user, register_user

class TestCameraService:
    """æ‘„åƒå¤´æœåŠ¡æµ‹è¯•"""
    
    def test_validate_camera_data_success(self):
        """æµ‹è¯•æ‘„åƒå¤´æ•°æ®éªŒè¯ - æ­£å¸¸æƒ…å†µ"""
        valid_data = {
            'name': 'æµ‹è¯•æ‘„åƒå¤´',
            'ip_address': '192.168.1.100',
            'port': 554,
            'url': 'rtsp://192.168.1.100:554/stream',
            'resolution': '1920x1080',
            'frame_rate': 30,
            'encoding_format': 'H.264'
        }
        
        result = CameraService.validate_camera_data(valid_data)
        assert result is True
    
    def test_validate_camera_data_missing_field(self):
        """æµ‹è¯•æ‘„åƒå¤´æ•°æ®éªŒè¯ - ç¼ºå°‘å­—æ®µ"""
        invalid_data = {
            'name': 'æµ‹è¯•æ‘„åƒå¤´',
            'ip_address': '192.168.1.100'
            # ç¼ºå°‘å…¶ä»–å¿…å¡«å­—æ®µ
        }
        
        with pytest.raises(ValueError, match="Missing required field"):
            CameraService.validate_camera_data(invalid_data)
    
    def test_validate_camera_data_invalid_ip(self):
        """æµ‹è¯•æ‘„åƒå¤´æ•°æ®éªŒè¯ - æ— æ•ˆIP"""
        invalid_data = {
            'name': 'æµ‹è¯•æ‘„åƒå¤´',
            'ip_address': '999.999.999.999',  # æ— æ•ˆIP
            'port': 554,
            'url': 'rtsp://test/stream',
            'resolution': '1920x1080',
            'frame_rate': 30,
            'encoding_format': 'H.264'
        }
        
        with pytest.raises(ValueError, match="Invalid IP address"):
            CameraService.validate_camera_data(invalid_data)
    
    @patch('cv2.VideoCapture')
    def test_test_camera_connection_success(self, mock_video_capture):
        """æµ‹è¯•æ‘„åƒå¤´è¿æ¥ - æˆåŠŸ"""
        mock_cap = Mock()
        mock_cap.isOpened.return_value = True
        mock_cap.read.return_value = (True, "frame_data")
        mock_video_capture.return_value = mock_cap
        
        result = CameraService.test_camera_connection("rtsp://test/stream")
        assert result is True
    
    @patch('cv2.VideoCapture')
    def test_test_camera_connection_failure(self, mock_video_capture):
        """æµ‹è¯•æ‘„åƒå¤´è¿æ¥ - å¤±è´¥"""
        mock_cap = Mock()
        mock_cap.isOpened.return_value = False
        mock_video_capture.return_value = mock_cap
        
        with pytest.raises(ConnectionError, match="Failed to connect"):
            CameraService.test_camera_connection("rtsp://test/stream")

class TestDetectionService:
    """æ£€æµ‹æœåŠ¡æµ‹è¯•"""
    
    @patch('app.services.detection_service.YOLOIntegration')
    @patch('app.services.detection_service.threading.Thread')
    def test_start_detection_success(self, mock_thread, mock_yolo):
        """æµ‹è¯•å¯åŠ¨æ£€æµ‹ - æˆåŠŸ"""
        mock_yolo_instance = Mock()
        mock_yolo.return_value = mock_yolo_instance
        
        mock_thread_instance = Mock()
        mock_thread.return_value = mock_thread_instance
        
        test_data = {
            'camera_id': 1,
            'stream_url': 'rtsp://test/stream',
            'model_path': 'yolov8n.pt',
            'save_dir': '/tmp/test',
            'retention_days': 30
        }
        
        result = DetectionService.start_detection(test_data)
        
        assert result['success'] is True
        assert result['camera_id'] == 1
        assert result['retention_days'] == 30
        mock_thread.assert_called()
    
    def test_start_detection_duplicate_camera(self):
        """æµ‹è¯•å¯åŠ¨æ£€æµ‹ - é‡å¤æ‘„åƒå¤´"""
        # å…ˆæ¨¡æ‹Ÿä¸€ä¸ªæ´»è·ƒçš„æ‘„åƒå¤´
        DetectionService.active_threads[1] = {
            'thread': Mock(),
            'status': 'running'
        }
        
        test_data = {
            'camera_id': 1,
            'stream_url': 'rtsp://test/stream',
            'model_path': 'yolov8n.pt',
            'save_dir': '/tmp/test'
        }
        
        result = DetectionService.start_detection(test_data)
        
        assert result['success'] is False
        assert "already being processed" in result['message']

class TestViolationService:
    """è¿è§„æœåŠ¡æµ‹è¯•"""
    
    def test_check_violations_no_camera(self):
        """æµ‹è¯•è¿è§„æ£€æŸ¥ - æ— æ‘„åƒå¤´"""
        service = ViolationService()
        
        # æ¨¡æ‹Ÿä¸å­˜åœ¨çš„æ‘„åƒå¤´
        with patch('app.services.violation_service.Camera.query.get', return_value=None):
            violations = service.check_violations(999, {})
            assert violations == []
    
    def test_check_violations_no_restricted_areas(self):
        """æµ‹è¯•è¿è§„æ£€æŸ¥ - æ— ç¦åœåŒºåŸŸ"""
        service = ViolationService()
        
        mock_camera = Mock()
        mock_camera.restricted_areas = None
        
        with patch('app.services.violation_service.Camera.query.get', return_value=mock_camera):
            violations = service.check_violations(1, {})
            assert violations == []
    
    @patch('app.services.violation_service.ViolationDetector.check_vehicle_violation')
    def test_check_violations_with_violation(self, mock_check):
        """æµ‹è¯•è¿è§„æ£€æŸ¥ - å‘ç°è¿è§„"""
        service = ViolationService()
        
        mock_camera = Mock()
        mock_camera.id = 1
        mock_camera.name = "æµ‹è¯•æ‘„åƒå¤´"
        mock_camera.restricted_areas = [{"id": 1, "points": [[0,0], [100,0], [100,100], [0,100]]}]
        
        # æ¨¡æ‹Ÿæ£€æµ‹åˆ°è¿è§„
        mock_check.return_value = [{
            'track_id': 123,
            'vehicle_type': 'car',
            'location': {'x': 50, 'y': 50},
            'area_id': 1
        }]
        
        with patch('app.services.violation_service.Camera.query.get', return_value=mock_camera):
            with patch('app.services.violation_service.db.session.add'):
                with patch('app.services.violation_service.db.session.commit'):
                    violations = service.check_violations(1, {})
                    
                    assert len(violations) == 1
                    assert violations[0]['vehicle_type'] == 'car'

class TestAuthService:
    """è®¤è¯æœåŠ¡æµ‹è¯•"""
    
    def test_authenticate_user_success(self):
        """æµ‹è¯•ç”¨æˆ·è®¤è¯ - æˆåŠŸ"""
        mock_user = Mock()
        mock_user.id = 1
        mock_user.role = 'admin'
        mock_user.password = 'hashed_password'
        
        with patch('app.services.auth_service.User.query.filter_by', return_value=Mock(first=Mock(return_value=mock_user))):
            with patch('werkzeug.security.check_password_hash', return_value=True):
                with patch('app.services.auth_service.jwt.encode', return_value='fake_token'):
                    success, token = authenticate_user('admin', 'password123')
                    
                    assert success is True
                    assert token == 'fake_token'
    
    def test_authenticate_user_wrong_password(self):
        """æµ‹è¯•ç”¨æˆ·è®¤è¯ - å¯†ç é”™è¯¯"""
        mock_user = Mock()
        mock_user.password = 'hashed_password'
        
        with patch('app.services.auth_service.User.query.filter_by', return_value=Mock(first=Mock(return_value=mock_user))):
            with patch('werkzeug.security.check_password_hash', return_value=False):
                success, token = authenticate_user('admin', 'wrong_password')
                
                assert success is False
                assert token is None
    
    def test_authenticate_user_not_found(self):
        """æµ‹è¯•ç”¨æˆ·è®¤è¯ - ç”¨æˆ·ä¸å­˜åœ¨"""
        with patch('app.services.auth_service.User.query.filter_by', return_value=Mock(first=Mock(return_value=None))):
            success, token = authenticate_user('nonexistent', 'password')
            
            assert success is False
            assert token is None

4.Â APIæ¥å£æµ‹è¯•Â (tests/test_routes.py)
import pytest
import json
from unittest.mock import Mock, patch
from flask import Flask
from app.routes.auth import auth_blueprint
from app.routes.camera import camera_blueprint
from app.routes.detection import detection_blueprint

class TestAuthRoutes:
    """è®¤è¯æ¥å£æµ‹è¯•"""
    
    @pytest.fixture
    def client(self):
        """åˆ›å»ºæµ‹è¯•å®¢æˆ·ç«¯"""
        app = Flask(__name__)
        app.config['TESTING'] = True
        app.register_blueprint(auth_blueprint)
        
        return app.test_client()
    
    @patch('app.routes.auth.register_user')
    def test_register_success(self, mock_register, client):
        """æµ‹è¯•æ³¨å†Œæ¥å£ - æˆåŠŸ"""
        mock_user = Mock()
        mock_register.return_value = mock_user
        
        response = client.post('/auth/register', 
                             json={
                                 'username': 'testuser',
                                 'password': 'password123',
                                 'role': 'user'
                             })
        
        assert response.status_code == 200
        data = json.loads(response.data)
        assert data['message'] == 'User registered successfully'
    
    @patch('app.routes.auth.authenticate_user')
    def test_login_success(self, mock_authenticate, client):
        """æµ‹è¯•ç™»å½•æ¥å£ - æˆåŠŸ"""
        mock_authenticate.return_value = (True, 'fake_jwt_token')
        
        response = client.post('/auth/login',
                             json={
                                 'username': 'admin',
                                 'password': 'password123'
                             })
        
        assert response.status_code == 200
        data = json.loads(response.data)
        assert data['token'] == 'fake_jwt_token'
    
    @patch('app.routes.auth.authenticate_user')
    def test_login_failure(self, mock_authenticate, client):
        """æµ‹è¯•ç™»å½•æ¥å£ - å¤±è´¥"""
        mock_authenticate.return_value = (False, None)
        
        response = client.post('/auth/login',
                             json={
                                 'username': 'admin',
                                 'password': 'wrong_password'
                             })
        
        assert response.status_code == 401
        data = json.loads(response.data)
        assert data['message'] == 'Invalid credentials'

class TestCameraRoutes:
    """æ‘„åƒå¤´æ¥å£æµ‹è¯•"""
    
    @pytest.fixture
    def client(self):
        app = Flask(__name__)
        app.config['TESTING'] = True
        app.register_blueprint(camera_blueprint)
        return app.test_client()
    
    @patch('app.routes.camera.CameraService.add_camera')
    def test_add_camera_success(self, mock_add, client):
        """æµ‹è¯•æ·»åŠ æ‘„åƒå¤´æ¥å£"""
        mock_add.return_value = {"success": True}
        
        camera_data = {
            "name": "æµ‹è¯•æ‘„åƒå¤´",
            "ip_address": "192.168.1.100",
            "port": 554,
            "url": "rtsp://192.168.1.100:554/stream",
            "resolution": "1920x1080",
            "frame_rate": 30,
            "encoding_format": "H.264"
        }
        
        response = client.post('/camera/cameras', json=camera_data)
        
        assert response.status_code == 201
        data = json.loads(response.data)
        assert data['message'] == 'Camera added successfully'
    
    @patch('app.routes.camera.CameraService.delete_camera')
    def test_delete_camera_success(self, mock_delete, client):
        """æµ‹è¯•åˆ é™¤æ‘„åƒå¤´æ¥å£"""
        mock_delete.return_value = {"success": True}
        
        response = client.delete('/camera/cameras/1')
        
        assert response.status_code == 200
        data = json.loads(response.data)
        assert data['message'] == 'Camera deleted successfully'

class TestDetectionRoutes:
    """æ£€æµ‹æ¥å£æµ‹è¯•"""
    
    @pytest.fixture
    def client(self):
        app = Flask(__name__)
        app.config['TESTING'] = True
        app.register_blueprint(detection_blueprint)
        return app.test_client()
    
    @patch('app.routes.detection.DetectionService.start_detection')
    def test_start_detection_success(self, mock_detect, client):
        """æµ‹è¯•å¯åŠ¨æ£€æµ‹æ¥å£"""
        mock_detect.return_value = {
            "success": True,
            "status": "started",
            "camera_id": 1
        }
        
        detection_data = {
            "camera_id": 1,
            "stream_url": "rtsp://test/stream",
            "model_path": "yolov8n.pt",
            "tracking_config": "botsort.yaml",
            "output_path": "streams/1/live.mp4"
        }
        
        response = client.post('/detection/detect', json=detection_data)
        
        assert response.status_code == 200
        data = json.loads(response.data)
        assert data['status'] == 'started'
    
    @patch('app.routes.detection.DetectionService.get_all_detections')
    def test_get_detections(self, mock_get, client):
        """æµ‹è¯•è·å–æ£€æµ‹è®°å½•æ¥å£"""
        mock_detections = [
            {
                "id": 1,
                "camera_id": 1,
                "timestamp": "2024-03-15 14:30:00",
                "vehicle_type": "car",
                "location": "Gate 1"
            }
        ]
        mock_get.return_value = mock_detections
        
        response = client.get('/detection/detections')
        
        assert response.status_code == 200
        data = json.loads(response.data)
        assert len(data) == 1
        assert data[0]['vehicle_type'] == 'car'

5.Â WebSocketæµ‹è¯•Â (tests/test_websocket.py)
import pytest
from unittest.mock import Mock, patch
from app.events.websocket_events import (
    handle_connect, handle_disconnect, handle_violation_alert,
    handle_video_frame, handle_camera_status
)

class TestWebSocketEvents:
    """WebSocketäº‹ä»¶æµ‹è¯•"""
    
    @patch('app.events.websocket_events._log_connection_status')
    def test_handle_connect(self, mock_log):
        """æµ‹è¯•è¿æ¥äº‹ä»¶"""
        # æ¨¡æ‹ŸSocketIOä¸Šä¸‹æ–‡
        with patch('app.events.websocket_events.socketio') as mock_socketio:
            handle_connect()
            
            mock_log.assert_called_with("connected to", "/violations")
    
    @patch('app.events.websocket_events._log_connection_status')
    def test_handle_disconnect(self, mock_log):
        """æµ‹è¯•æ–­å¼€äº‹ä»¶"""
        handle_disconnect()
        mock_log.assert_called_with("disconnected from", "/violations")
    
    @patch('app.events.websocket_events.emit')
    def test_handle_violation_alert(self, mock_emit):
        """æµ‹è¯•è¿è§„æé†’äº‹ä»¶"""
        test_data = {
            "camera_id": 1,
            "violation_type": "parking",
            "location": {"x": 100, "y": 200},
            "timestamp": "2024-03-15 14:30:00"
        }
        
        handle_violation_alert(test_data)
        
        mock_emit.assert_called_with(
            'violation_alert', test_data, broadcast=True
        )
    
    @patch('app.events.websocket_events.socketio')
    def test_handle_join_stream(self, mock_socketio):
        """æµ‹è¯•åŠ å…¥è§†é¢‘æµ"""
        from app.events.websocket_events import handle_join_stream
        
        test_data = {"camera_id": 1}
        
        handle_join_stream(test_data)
        
        mock_socketio.join_room.assert_called_with(
            'camera_1', namespace='/video'
        )

6.Â å®‰å…¨æµ‹è¯•Â (tests/test_security.py)
import pytest
import jwt
from datetime import datetime, timedelta
from app.services.auth_service import create_jwt_token, SECRET_KEY

class TestSecurity:
    """å®‰å…¨æµ‹è¯•"""
    
    def test_jwt_token_creation(self):
        """æµ‹è¯•JWTä»¤ç‰Œåˆ›å»º"""
        mock_user = Mock()
        mock_user.id = 1
        mock_user.role = 'admin'
        
        token = create_jwt_token(mock_user)
        
        # éªŒè¯ä»¤ç‰Œæ ¼å¼
        assert isinstance(token, str)
        assert len(token) > 0
        
        # è§£ç éªŒè¯
        decoded = jwt.decode(token, SECRET_KEY, algorithms=['HS256'])
        assert decoded['user_id'] == 1
        assert decoded['role'] == 'admin'
        assert 'exp' in decoded
    
    def test_jwt_token_expiration(self):
        """æµ‹è¯•JWTä»¤ç‰Œè¿‡æœŸ"""
        mock_user = Mock()
        mock_user.id = 1
        mock_user.role = 'user'
        
        token = create_jwt_token(mock_user)
        
        # éªŒè¯ä»¤ç‰Œåœ¨æœ‰æ•ˆæœŸå†…
        decoded = jwt.decode(token, SECRET_KEY, algorithms=['HS256'])
        exp_time = datetime.fromtimestamp(decoded['exp'])
        assert exp_time > datetime.utcnow()
    
    def test_sql_injection_prevention(self):
        """æµ‹è¯•SQLæ³¨å…¥é˜²æŠ¤"""
        # æ¨¡æ‹Ÿæ¶æ„è¾“å…¥
        malicious_input = "admin' OR '1'='1"
        
        # åœ¨æœåŠ¡å±‚ï¼Œåº”è¯¥ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢è€Œä¸æ˜¯å­—ç¬¦ä¸²æ‹¼æ¥
        # è¿™é‡Œæµ‹è¯•å­—ç¬¦ä¸²ä¸­æ˜¯å¦åŒ…å«SQLå…³é”®å­—ï¼ˆç®€åŒ–æµ‹è¯•ï¼‰
        sql_keywords = ['SELECT', 'INSERT', 'UPDATE', 'DELETE', 'DROP', 'UNION']
        
        for keyword in sql_keywords:
            assert keyword not in malicious_input.lower()
    
    def test_password_hashing(self):
        """æµ‹è¯•å¯†ç å“ˆå¸Œ"""
        from werkzeug.security import generate_password_hash, check_password_hash
        
        password = "MySecurePassword123"
        hashed = generate_password_hash(password)
        
        # éªŒè¯å“ˆå¸Œç‰¹æ€§
        assert hashed != password
        assert len(hashed) > len(password)
        
        # éªŒè¯å¯†ç æ£€æŸ¥
        assert check_password_hash(hashed, password) is True
        assert check_password_hash(hashed, "WrongPassword") is False

7.Â è¦†ç›–ç‡æµ‹è¯•è„šæœ¬Â (tests/test_coverage.py)
import pytest
from app import create_app
from app.models import db
from app.services.camera_service import CameraService
from app.services.detection_service import DetectionService
from app.services.violation_service import ViolationService

class TestCoverage:
    """è¦†ç›–ç‡æµ‹è¯• - è¦†ç›–ä¸»è¦ä»£ç è·¯å¾„"""
    
    @pytest.fixture
    def app(self):
        app = create_app()
        app.config['TESTING'] = True
        app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///:memory:'
        return app
    
    def test_full_coverage_paths(self, app):
        """æµ‹è¯•å®Œæ•´ä»£ç è·¯å¾„"""
        with app.app_context():
            # 1. æ•°æ®åº“æ“ä½œ
            db.create_all()
            
            # 2. æœåŠ¡å±‚æ‰€æœ‰æ–¹æ³•
            # åˆ›å»ºæµ‹è¯•æ•°æ®
            test_camera_data = {
                'name': 'è¦†ç›–ç‡æµ‹è¯•æ‘„åƒå¤´',
                'ip_address': '192.168.1.200',
                'port': 554,
                'url': 'rtsp://test/stream',
                'resolution': '1280x720',
                'frame_rate': 25,
                'encoding_format': 'H.265'
            }
            
            # æµ‹è¯•éªŒè¯é€»è¾‘ï¼ˆä¸å®é™…è¿æ¥ï¼‰
            with patch('cv2.VideoCapture'):
                # æµ‹è¯•æ‘„åƒå¤´æœåŠ¡
                CameraService.validate_camera_data(test_camera_data)
                
                # æµ‹è¯•æ£€æµ‹æœåŠ¡çŠ¶æ€è·å–
                status = DetectionService.get_processing_status()
                assert isinstance(status, dict)
                
                # æµ‹è¯•è¿è§„æœåŠ¡
                violation_service = ViolationService()
                filters = {'camera_id': 1}
                violations = violation_service.get_violations(filters)
                assert isinstance(violations, list)
            
            # æ¸…ç†
            db.drop_all()
    
    def test_error_handling_paths(self):
        """æµ‹è¯•é”™è¯¯å¤„ç†è·¯å¾„"""
        # æµ‹è¯•æ— æ•ˆæ•°æ®éªŒè¯
        invalid_data = {'name': 'æµ‹è¯•'}
        
        with pytest.raises(ValueError):
            CameraService.validate_camera_data(invalid_data)
        
        # æµ‹è¯•ç©ºå‚æ•°å¤„ç†
        violation_service = ViolationService()
        empty_violations = violation_service.get_violations(None)
        assert empty_violations == []

é˜¶æ®µä¸‰ï¼šå®éªŒæ‰§è¡Œä¸æŠ¥å‘Šç”Ÿæˆ
1.Â åˆ›å»ºå®éªŒæ‰§è¡Œè„šæœ¬Â (run_experiment.py)
#!/usr/bin/env python3
"""
å®‰å…¨æµ‹è¯•å®éªŒ - å®Œæ•´æ‰§è¡Œè„šæœ¬
è¥¿å—äº¤é€šå¤§å­¦ è½¯ä»¶æµ‹è¯•è¯¾ç¨‹å®éªŒ
"""

import os
import sys
import json
import subprocess
from datetime import datetime
from pathlib import Path

class SecurityTestExperiment:
    def __init__(self):
        self.project_root = Path(__file__).parent
        self.results = {
            "experiment_info": {
                "course": "è½¯ä»¶æµ‹è¯•",
                "university": "è¥¿å—äº¤é€šå¤§å­¦",
                "experiment_date": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                "project": "è½¦è¾†æ£€æµ‹ç³»ç»Ÿå®‰å…¨æµ‹è¯•",
                "team_members": ["è¯·å¡«å†™ç»„å‘˜å§“å"]  # ä¿®æ”¹è¿™é‡Œ
            },
            "test_execution": {
                "total_tests": 0,
                "passed": 0,
                "failed": 0,
                "details": {}
            },
            "coverage_analysis": {
                "statement_coverage": 0.0,
                "branch_coverage": 0.0,
                "file_details": {}
            },
            "defect_analysis": [],
            "conclusions": {}
        }
    
    def run_tests(self):
        """è¿è¡Œæ‰€æœ‰æµ‹è¯•ç”¨ä¾‹"""
        print("=" * 60)
        print("é˜¶æ®µ1: è¿è¡Œæ‰€æœ‰æµ‹è¯•ç”¨ä¾‹")
        print("=" * 60)
        
        test_modules = [
            ("é…ç½®æ–‡ä»¶æµ‹è¯•", "test_config.py"),
            ("æ•°æ®æ¨¡å‹æµ‹è¯•", "test_models.py"),
            ("æœåŠ¡å±‚æµ‹è¯•", "test_services.py"),
            ("APIæ¥å£æµ‹è¯•", "test_routes.py"),
            ("WebSocketæµ‹è¯•", "test_websocket.py"),
            ("å®‰å…¨æµ‹è¯•", "test_security.py"),
            ("è¦†ç›–ç‡æµ‹è¯•", "test_coverage.py")
        ]
        
        for module_name, filename in test_modules:
            filepath = self.project_root / "tests" / filename
            if filepath.exists():
                print(f"\nğŸ“‹ æ‰§è¡Œ: {module_name}")
                
                result = subprocess.run(
                    [sys.executable, "-m", "pytest", str(filepath), "-v"],
                    capture_output=True,
                    text=True,
                    cwd=self.project_root
                )
                
                # è§£æç»“æœ
                self._parse_test_results(module_name, result)
            else:
                print(f"âš ï¸  è·³è¿‡: {module_name} (æ–‡ä»¶ä¸å­˜åœ¨)")
        
        print(f"\nâœ… æµ‹è¯•æ‰§è¡Œå®Œæˆ")
        print(f"æ€»è®¡: {self.results['test_execution']['total_tests']} ä¸ªæµ‹è¯•")
        print(f"é€šè¿‡: {self.results['test_execution']['passed']}")
        print(f"å¤±è´¥: {self.results['test_execution']['failed']}")
    
    def _parse_test_results(self, module_name, result):
        """è§£ææµ‹è¯•ç»“æœ"""
        lines = result.stdout.split('\n')
        passed = 0
        failed = 0
        
        for line in lines:
            if 'PASSED' in line:
                passed += 1
            elif 'FAILED' in line or 'ERROR' in line:
                failed += 1
        
        self.results['test_execution']['details'][module_name] = {
            "passed": passed,
            "failed": failed,
            "return_code": result.returncode,
            "summary": f"{passed} passed, {failed} failed"
        }
        
        self.results['test_execution']['total_tests'] += (passed + failed)
        self.results['test_execution']['passed'] += passed
        self.results['test_execution']['failed'] += failed
        
        if failed > 0:
            print(f"  âŒ {module_name}: {passed}é€šè¿‡, {failed}å¤±è´¥")
            # è®°å½•ç¼ºé™·
            self._record_defects(module_name, result.stderr)
        else:
            print(f"  âœ… {module_name}: {passed}é€šè¿‡, {failed}å¤±è´¥")
    
    def _record_defects(self, module_name, error_output):
        """è®°å½•å‘ç°çš„ç¼ºé™·"""
        defect_id = f"DEFECT-{len(self.results['defect_analysis']) + 1:03d}"
        
        defect = {
            "id": defect_id,
            "module": module_name,
            "symptom": "æµ‹è¯•ç”¨ä¾‹æ‰§è¡Œå¤±è´¥",
            "error_details": error_output[:500],  # æˆªå–å‰500å­—ç¬¦
            "severity": "Medium",
            "status": "å¾…åˆ†æ"
        }
        
        self.results['defect_analysis'].append(defect)
    
    def calculate_coverage(self):
        """è®¡ç®—æµ‹è¯•è¦†ç›–ç‡"""
        print("\n" + "=" * 60)
        print("é˜¶æ®µ2: è®¡ç®—æµ‹è¯•è¦†ç›–ç‡")
        print("=" * 60)
        
        coverage_cmd = [
            sys.executable, "-m", "pytest",
            "tests/",
            "--cov=app",
            "--cov-branch",
            "--cov-report=json:coverage_report.json",
            "--cov-report=html:coverage_html",
            "--cov-report=term-missing"
        ]
        
        print("ğŸ“Š æ‰§è¡Œè¦†ç›–ç‡åˆ†æ...")
        result = subprocess.run(
            coverage_cmd,
            capture_output=True,
            text=True,
            cwd=self.project_root
        )
        
        # è§£æè¦†ç›–ç‡æŠ¥å‘Š
        coverage_file = self.project_root / "coverage_report.json"
        if coverage_file.exists():
            with open(coverage_file, 'r') as f:
                coverage_data = json.load(f)
                
                totals = coverage_data['totals']
                self.results['coverage_analysis']['statement_coverage'] = totals['percent_covered']
                self.results['coverage_analysis']['branch_coverage'] = totals['percent_covered_branches']
                
                # åˆ†æå…³é”®æ–‡ä»¶è¦†ç›–ç‡
                key_files = [
                    'app/services/detection_service.py',
                    'app/services/camera_service.py',
                    'app/services/violation_service.py',
                    'app/utils/websocket_utils.py',
                    'app/routes/detection.py'
                ]
                
                for file_data in coverage_data['files']:
                    filename = file_data['filename']
                    if any(key_file in filename for key_file in key_files):
                        self.results['coverage_analysis']['file_details'][filename] = {
                            'statement': file_data['summary']['percent_covered'],
                            'branch': file_data['summary']['percent_covered_branches'],
                            'missing_lines': file_data['summary']['missing_lines']
                        }
        
        print(f"âœ… è¦†ç›–ç‡åˆ†æå®Œæˆ")
        print(f"è¯­å¥è¦†ç›–ç‡: {self.results['coverage_analysis']['statement_coverage']:.2f}%")
        print(f"åˆ†æ”¯è¦†ç›–ç‡: {self.results['coverage_analysis']['branch_coverage']:.2f}%")
    
    def analyze_defects(self):
        """åˆ†æç¼ºé™·æ ¹å› """
        print("\n" + "=" * 60)
        print("é˜¶æ®µ3: åˆ†æç¼ºé™·æ ¹å› ")
        print("=" * 60)
        
        # åŸºäºæµ‹è¯•å¤±è´¥ç»“æœè¿›è¡Œç¼ºé™·åˆ†æ
        for defect in self.results['defect_analysis']:
            # æ ¹æ®æ¨¡å—å’Œé”™è¯¯ä¿¡æ¯æ¨æ–­æ ¹å› 
            if "camera_service" in defect['module'].lower():
                defect['root_cause'] = "æ•°æ®éªŒè¯é€»è¾‘ä¸å®Œæ•´æˆ–å¼‚å¸¸å¤„ç†ç¼ºå¤±"
                defect['fix_suggestion'] = "1. å®Œå–„è¾“å…¥éªŒè¯ 2. æ·»åŠ å¼‚å¸¸æ•è· 3. ä¼˜åŒ–é”™è¯¯æç¤º"
            elif "auth_service" in defect['module'].lower():
                defect['root_cause'] = "è®¤è¯é€»è¾‘é”™è¯¯æˆ–ä»¤ç‰Œå¤„ç†é—®é¢˜"
                defect['fix_suggestion'] = "1. æ£€æŸ¥å¯†ç éªŒè¯é€»è¾‘ 2. éªŒè¯JWTä»¤ç‰Œç”Ÿæˆ"
            elif "violation" in defect['module'].lower():
                defect['root_cause'] = "è¿è§„æ£€æµ‹é€»è¾‘ç¼ºé™·æˆ–ç¼“å­˜å¤„ç†é—®é¢˜"
                defect['fix_suggestion'] = "1. æ£€æŸ¥åŒºåŸŸæ£€æµ‹ç®—æ³• 2. ä¼˜åŒ–ç¼“å­˜ç­–ç•¥"
            else:
                defect['root_cause'] = "ä»£ç é€»è¾‘é”™è¯¯æˆ–æµ‹è¯•ç¯å¢ƒé—®é¢˜"
                defect['fix_suggestion'] = "1. æ£€æŸ¥ç›¸å…³ä»£ç  2. éªŒè¯æµ‹è¯•æ•°æ®"
            
            defect['status'] = "å·²åˆ†æ"
            print(f"ğŸ” åˆ†æç¼ºé™· {defect['id']}: {defect['root_cause']}")
    
    def generate_report(self):
        """ç”Ÿæˆå®éªŒæŠ¥å‘Š"""
        print("\n" + "=" * 60)
        print("é˜¶æ®µ4: ç”Ÿæˆå®éªŒæŠ¥å‘Š")
        print("=" * 60)
        
        report = self._create_markdown_report()
        
        # ä¿å­˜æŠ¥å‘Š
        report_file = self.project_root / "å®‰å…¨æµ‹è¯•å®éªŒæŠ¥å‘Š.md"
        with open(report_file, 'w', encoding='utf-8') as f:
            f.write(report)
        
        # ä¿å­˜JSONæ•°æ®
        json_file = self.project_root / "experiment_results.json"
        with open(json_file, 'w', encoding='utf-8') as f:
            json.dump(self.results, f, ensure_ascii=False, indent=2)
        
        print(f"ğŸ“„ å®éªŒæŠ¥å‘Šå·²ç”Ÿæˆ: {report_file}")
        print(f"ğŸ“Š è¯¦ç»†æ•°æ®å·²ä¿å­˜: {json_file}")
        print(f"ğŸ“ˆ è¦†ç›–ç‡æŠ¥å‘Š: {self.project_root}/coverage_html/index.html")
    
    def _create_markdown_report(self):
        """åˆ›å»ºMarkdownæ ¼å¼æŠ¥å‘Š"""
        report = f"""# å®‰å…¨æµ‹è¯•å®éªŒæŠ¥å‘Š

## å®éªŒä¿¡æ¯
- **è¯¾ç¨‹**: {self.results['experiment_info']['course']}
- **å­¦æ ¡**: {self.results['experiment_info']['university']}
- **å®éªŒæ—¥æœŸ**: {self.results['experiment_info']['experiment_date']}
- **å®éªŒé¡¹ç›®**: {self.results['experiment_info']['project']}
- **ç»„å‘˜**: {', '.join(self.results['experiment_info']['team_members'])}

## 1. æµ‹è¯•æ‰§è¡Œç»“æœ

### æ€»ä½“ç»Ÿè®¡
- æµ‹è¯•ç”¨ä¾‹æ€»æ•°: {self.results['test_execution']['total_tests']}
- é€šè¿‡: {self.results['test_execution']['passed']}
- å¤±è´¥: {self.results['test_execution']['failed']}
- é€šè¿‡ç‡: {self.results['test_execution']['passed']/max(self.results['test_execution']['total_tests'], 1)*100:.1f}%

### è¯¦ç»†ç»“æœ
| æµ‹è¯•æ¨¡å— | é€šè¿‡æ•° | å¤±è´¥æ•° | çŠ¶æ€ |
|---------|--------|--------|------|
"""
        
        for module, details in self.results['test_execution']['details'].items():
            status = "âœ… é€šè¿‡" if details['failed'] == 0 else "âŒ å¤±è´¥"
            report += f"| {module} | {details['passed']} | {details['failed']} | {status} |\n"
        
        report += """
## 2. è¦†ç›–ç‡åˆ†æ

### æ€»ä½“è¦†ç›–ç‡
- **è¯­å¥è¦†ç›–ç‡**: {:.2f}%
- **åˆ†æ”¯è¦†ç›–ç‡**: {:.2f}%

### å…³é”®æ–‡ä»¶è¦†ç›–ç‡
| æ–‡ä»¶ | è¯­å¥è¦†ç›–ç‡ | åˆ†æ”¯è¦†ç›–ç‡ | ç¼ºå¤±è¡Œæ•° |
|------|------------|------------|----------|
""".format(
    self.results['coverage_analysis']['statement_coverage'],
    self.results['coverage_analysis']['branch_coverage']
)
        
        for file, coverage in self.results['coverage_analysis']['file_details'].items():
            report += f"| {file} | {coverage['statement']:.1f}% | {coverage['branch']:.1f}% | {coverage['missing_lines']} |\n"
        
        report += """
## 3. ç¼ºé™·åˆ†æ

### å‘ç°çš„ç¼ºé™·
"""
        
        if self.results['defect_analysis']:
            for defect in self.results['defect_analysis']:
                report += f"""
#### ç¼ºé™· {defect['id']}
- **æ¨¡å—**: {defect['module']}
- **ç°è±¡**: {defect['symptom']}
- **æ ¹å› **: {defect.get('root_cause', 'å¾…åˆ†æ')}
- **ä¸¥é‡ç¨‹åº¦**: {defect['severity']}
- **ä¿®å¤å»ºè®®**: {defect.get('fix_suggestion', 'å¾…åˆ¶å®š')}
- **çŠ¶æ€**: {defect['status']}

"""
        else:
            report += "âœ… æœªå‘ç°ç¼ºé™·\n"
        
        report += """
## 4. å®éªŒç»“è®º

### ä¸»è¦å‘ç°
1. **ä»£ç è´¨é‡**: æ€»ä½“ä»£ç ç»“æ„è‰¯å¥½ï¼Œæ¨¡å—åˆ’åˆ†æ¸…æ™°
2. **æµ‹è¯•è¦†ç›–**: æ ¸å¿ƒä¸šåŠ¡é€»è¾‘è¦†ç›–ç‡{:.1f}%ï¼Œéœ€è¦åŠ å¼ºè¾¹ç•Œæ¡ä»¶æµ‹è¯•
3. **ç¼ºé™·åˆ†å¸ƒ**: ä¸»è¦é—®é¢˜é›†ä¸­åœ¨æ•°æ®éªŒè¯å’Œå¼‚å¸¸å¤„ç†

### æ”¹è¿›å»ºè®®
1. **æé«˜æµ‹è¯•è¦†ç›–ç‡**: é’ˆå¯¹è¦†ç›–ç‡ä½çš„æ–‡ä»¶è¡¥å……æµ‹è¯•ç”¨ä¾‹
2. **åŠ å¼ºå¼‚å¸¸å¤„ç†**: å®Œå–„æ‰€æœ‰æœåŠ¡çš„å¼‚å¸¸æ•è·å’Œå¤„ç†
3. **ä¼˜åŒ–æ€§èƒ½**: å¯¹æ£€æµ‹æœåŠ¡è¿›è¡Œæ€§èƒ½æµ‹è¯•å’Œä¼˜åŒ–
4. **å®‰å…¨åŠ å›º**: åŠ å¼ºè¾“å…¥éªŒè¯å’Œæƒé™æ§åˆ¶

### å®éªŒæ€»ç»“
æœ¬æ¬¡å®‰å…¨æµ‹è¯•å®éªŒå®Œæˆäº†å¯¹è½¦è¾†æ£€æµ‹ç³»ç»Ÿçš„å…¨é¢æµ‹è¯•ï¼ŒåŒ…æ‹¬åŠŸèƒ½æµ‹è¯•ã€è¦†ç›–ç‡åˆ†æå’Œç¼ºé™·åˆ†æã€‚é€šè¿‡å®éªŒï¼ŒéªŒè¯äº†ç³»ç»Ÿæ ¸å¿ƒåŠŸèƒ½çš„æ­£ç¡®æ€§ï¼Œè¯†åˆ«äº†éœ€è¦æ”¹è¿›çš„ä»£ç åŒºåŸŸï¼Œä¸ºç³»ç»Ÿä¼˜åŒ–æä¾›äº†æ˜ç¡®æ–¹å‘ã€‚

---
**å®éªŒå®Œæˆæ—¶é—´**: {}

**æŒ‡å¯¼æ•™å¸ˆ**: [è¯·å¡«å†™]

**å®éªŒè¯„åˆ†**: [è¯·å¡«å†™]
""".format(
    self.results['coverage_analysis']['statement_coverage'],
    datetime.now().strftime("%Yå¹´%mæœˆ%dæ—¥ %H:%M")
)
        
        return report
    
    def run(self):
        """æ‰§è¡Œå®Œæ•´å®éªŒæµç¨‹"""
        print("ğŸš€ å¼€å§‹å®‰å…¨æµ‹è¯•å®éªŒ")
        print("=" * 60)
        
        try:
            self.run_tests()
            self.calculate_coverage()
            self.analyze_defects()
            self.generate_report()
            
            print("\n" + "=" * 60)
            print("ğŸ‰ å®éªŒå®Œæˆï¼")
            print("=" * 60)
            print("è¯·æŸ¥çœ‹ä»¥ä¸‹æ–‡ä»¶ï¼š")
            print("1. å®‰å…¨æµ‹è¯•å®éªŒæŠ¥å‘Š.md - å®Œæ•´å®éªŒæŠ¥å‘Š")
            print("2. experiment_results.json - è¯¦ç»†å®éªŒæ•°æ®")
            print("3. coverage_html/ - è¦†ç›–ç‡å¯è§†åŒ–æŠ¥å‘Š")
            print("\nç¥å®éªŒé¡ºåˆ©ï¼")
            
        except Exception as e:
            print(f"âŒ å®éªŒæ‰§è¡Œå‡ºé”™: {str(e)}")
            sys.exit(1)

if __name__ == "__main__":
    experiment = SecurityTestExperiment()
experiment.run()

2.Â è¿è¡Œå®éªŒ
# 1. å®‰è£…æµ‹è¯•ä¾èµ–
pip install -r requirements-test.txt

# 2. è¿è¡Œå®Œæ•´å®éªŒ
python run_experiment.py

# 3. æˆ–è€…åˆ†æ­¥è¿è¡Œ
python -m pytest tests/ -v                  # åªè¿è¡Œæµ‹è¯•
python -m pytest tests/ --cov=app --cov-report=html  # ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Š

3.Â æŸ¥çœ‹ç»“æœ
1.ç»ˆç«¯è¾“å‡ºï¼šå®æ—¶æ˜¾ç¤ºæµ‹è¯•è¿›åº¦å’Œç»“æœ
2.HTMLæŠ¥å‘Šï¼šcoverage_html/index.htmlÂ - äº¤äº’å¼è¦†ç›–ç‡æŠ¥å‘Š
3.å®éªŒæŠ¥å‘Šï¼šå®‰å…¨æµ‹è¯•å®éªŒæŠ¥å‘Š.mdÂ - å®Œæ•´å®éªŒæŠ¥å‘Š
4.è¯¦ç»†æ•°æ®ï¼šexperiment_results.jsonÂ - åŸå§‹å®éªŒæ•°æ®
